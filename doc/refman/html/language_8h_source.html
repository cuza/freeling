<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeLing: language.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeLing
   &#160;<span id="projectnumber">3.1</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_1227859d41f15db21961dcfca4ef2341.html">src</a>      </li>
      <li class="navelem"><a class="el" href="dir_5f8b0c6cd304c2fe083c990034b9eabd.html">include</a>      </li>
      <li class="navelem"><a class="el" href="dir_0d07337227cf901df9a3d79a64c6c497.html">freeling</a>      </li>
      <li class="navelem"><a class="el" href="dir_3e1af9fd0e33a6cb9bb5303d785d29d8.html">morfo</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">language.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="language_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00002"></a>00002 <span class="comment">//</span>
<a name="l00003"></a>00003 <span class="comment">//    FreeLing - Open Source Language Analyzers</span>
<a name="l00004"></a>00004 <span class="comment">//</span>
<a name="l00005"></a>00005 <span class="comment">//    Copyright (C) 2004   TALP Research Center</span>
<a name="l00006"></a>00006 <span class="comment">//                         Universitat Politecnica de Catalunya</span>
<a name="l00007"></a>00007 <span class="comment">//</span>
<a name="l00008"></a>00008 <span class="comment">//    This library is free software; you can redistribute it and/or</span>
<a name="l00009"></a>00009 <span class="comment">//    modify it under the terms of the GNU General Public</span>
<a name="l00010"></a>00010 <span class="comment">//    License as published by the Free Software Foundation; either</span>
<a name="l00011"></a>00011 <span class="comment">//    version 3 of the License, or (at your option) any later version.</span>
<a name="l00012"></a>00012 <span class="comment">//</span>
<a name="l00013"></a>00013 <span class="comment">//    This library is distributed in the hope that it will be useful,</span>
<a name="l00014"></a>00014 <span class="comment">//    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00015"></a>00015 <span class="comment">//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00016"></a>00016 <span class="comment">//    General Public License for more details.</span>
<a name="l00017"></a>00017 <span class="comment">//</span>
<a name="l00018"></a>00018 <span class="comment">//    You should have received a copy of the GNU General Public</span>
<a name="l00019"></a>00019 <span class="comment">//    License along with this library; if not, write to the Free Software</span>
<a name="l00020"></a>00020 <span class="comment">//    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 <span class="comment">//    contact: Lluis Padro (padro@lsi.upc.es)</span>
<a name="l00023"></a>00023 <span class="comment">//             TALP Research Center</span>
<a name="l00024"></a>00024 <span class="comment">//             despatx C6.212 - Campus Nord UPC</span>
<a name="l00025"></a>00025 <span class="comment">//             08034 Barcelona.  SPAIN</span>
<a name="l00026"></a>00026 <span class="comment">//</span>
<a name="l00028"></a>00028 <span class="comment"></span>
<a name="l00029"></a>00029 <span class="preprocessor">#ifndef _LANGUAGE</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span><span class="preprocessor">#define _LANGUAGE</span>
<a name="l00031"></a>00031 <span class="preprocessor"></span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;list&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;set&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;<a class="code" href="regexp_8h.html">freeling/regexp.h</a>&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;<a class="code" href="windll_8h.html">freeling/windll.h</a>&quot;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;<a class="code" href="tree_8h.html">freeling/tree.h</a>&quot;</span>
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="keyword">namespace </span>freeling {
<a name="l00043"></a>00043 
<a name="l00044"></a>00044   <span class="keyword">class </span>word; <span class="comment">// predeclaration</span>
<a name="l00045"></a>00045 
<a name="l00050"></a>00050 
<a name="l00051"></a><a class="code" href="classfreeling_1_1analysis.html">00051</a>   <span class="keyword">class </span>WINDLL <a class="code" href="classfreeling_1_1analysis.html" title="Class analysis stores a possible reading (lemma, PoS, probability, distance) for a word...">analysis</a> {
<a name="l00052"></a>00052 
<a name="l00053"></a>00053   <span class="keyword">private</span>:
<a name="l00055"></a><a class="code" href="classfreeling_1_1analysis.html#a1088b78bed46b6926e5fe068c4de5fa6">00055</a>     std::wstring <a class="code" href="classfreeling_1_1analysis.html#a1088b78bed46b6926e5fe068c4de5fa6" title="lemma">lemma</a>;
<a name="l00057"></a><a class="code" href="classfreeling_1_1analysis.html#abaeeda40973349af0d0892de3c5c49d5">00057</a>     std::wstring <a class="code" href="classfreeling_1_1analysis.html#abaeeda40973349af0d0892de3c5c49d5" title="PoS tag.">tag</a>;
<a name="l00059"></a><a class="code" href="classfreeling_1_1analysis.html#a12c7702b55694948e129c7f98e78de09">00059</a>     <span class="keywordtype">double</span> <a class="code" href="classfreeling_1_1analysis.html#a12c7702b55694948e129c7f98e78de09" title="probability of that lemma-tag given the word">prob</a>;
<a name="l00061"></a><a class="code" href="classfreeling_1_1analysis.html#ac35f6b62fb11b73f860a676b5e90a7bf">00061</a>     <span class="keywordtype">double</span> <a class="code" href="classfreeling_1_1analysis.html#ac35f6b62fb11b73f860a676b5e90a7bf" title="distance from a added analysis from corrector to the original word">distance</a>;
<a name="l00063"></a><a class="code" href="classfreeling_1_1analysis.html#a2ade23352a299466670f3432cc131443">00063</a>     std::list&lt;std::pair&lt;std::wstring,double&gt; &gt; <a class="code" href="classfreeling_1_1analysis.html#a2ade23352a299466670f3432cc131443" title="list of possible senses for that analysis, along with their rank as attributed by the ukb PPR algorit...">senses</a>;
<a name="l00065"></a><a class="code" href="classfreeling_1_1analysis.html#a6f9e540849d114fb343b1e54c594f595">00065</a>     std::list&lt;word&gt; <a class="code" href="classfreeling_1_1analysis.html#a6f9e540849d114fb343b1e54c594f595" title="information to retokenize the word after tagging if this analysis is selected">retok</a>;
<a name="l00066"></a>00066 
<a name="l00067"></a>00067     <span class="comment">// store which sequences --among the kbest proposed by </span>
<a name="l00068"></a>00068     <span class="comment">// the tagger-- contain this analysis</span>
<a name="l00069"></a><a class="code" href="classfreeling_1_1analysis.html#a9ed0c6e299941579346a25f89c7c7f1e">00069</a>     std::set&lt;int&gt; <a class="code" href="classfreeling_1_1analysis.html#a9ed0c6e299941579346a25f89c7c7f1e">selected_kbest</a>;
<a name="l00070"></a>00070 
<a name="l00071"></a>00071   <span class="keyword">public</span>:
<a name="l00073"></a><a class="code" href="classfreeling_1_1analysis.html#acc3d196c128e8813a583d99e17df1e9a">00073</a>     std::vector&lt;std::wstring&gt; <a class="code" href="classfreeling_1_1analysis.html#acc3d196c128e8813a583d99e17df1e9a" title="user-managed data, we just store it.">user</a>;
<a name="l00074"></a>00074 
<a name="l00076"></a>00076     <a class="code" href="classfreeling_1_1analysis.html" title="Class analysis stores a possible reading (lemma, PoS, probability, distance) for a word...">analysis</a>();
<a name="l00078"></a>00078     <a class="code" href="classfreeling_1_1analysis.html" title="Class analysis stores a possible reading (lemma, PoS, probability, distance) for a word...">analysis</a>(<span class="keyword">const</span> std::wstring &amp;, <span class="keyword">const</span> std::wstring &amp;);
<a name="l00080"></a>00080     <a class="code" href="classfreeling_1_1analysis.html" title="Class analysis stores a possible reading (lemma, PoS, probability, distance) for a word...">analysis</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classfreeling_1_1analysis.html" title="Class analysis stores a possible reading (lemma, PoS, probability, distance) for a word...">analysis</a>&amp;);
<a name="l00081"></a>00081 
<a name="l00082"></a>00082     <span class="keywordtype">void</span> init(<span class="keyword">const</span> std::wstring &amp;l, <span class="keyword">const</span> std::wstring &amp;t);
<a name="l00083"></a>00083     <span class="keywordtype">void</span> set_lemma(<span class="keyword">const</span> std::wstring &amp;);
<a name="l00084"></a>00084     <span class="keywordtype">void</span> set_tag(<span class="keyword">const</span> std::wstring &amp;);
<a name="l00085"></a>00085     <span class="keywordtype">void</span> set_prob(<span class="keywordtype">double</span>);
<a name="l00086"></a>00086     <span class="keywordtype">void</span> set_distance(<span class="keywordtype">double</span>);
<a name="l00087"></a>00087     <span class="keywordtype">void</span> set_retokenizable(<span class="keyword">const</span> std::list&lt;word&gt; &amp;);
<a name="l00088"></a>00088 
<a name="l00089"></a>00089     <span class="keywordtype">bool</span> has_prob() <span class="keyword">const</span>;
<a name="l00090"></a>00090     <span class="keywordtype">bool</span> has_distance() <span class="keyword">const</span>;
<a name="l00091"></a>00091     std::wstring get_lemma() <span class="keyword">const</span>;
<a name="l00092"></a>00092     std::wstring get_tag() <span class="keyword">const</span>;
<a name="l00093"></a>00093     <span class="keywordtype">double</span> get_prob() <span class="keyword">const</span>;
<a name="l00094"></a>00094     <span class="keywordtype">double</span> get_distance() <span class="keyword">const</span>;
<a name="l00095"></a>00095     <span class="keywordtype">bool</span> is_retokenizable() <span class="keyword">const</span>;
<a name="l00096"></a>00096     std::list&lt;word&gt;&amp; get_retokenizable();
<a name="l00097"></a>00097     <span class="keyword">const</span> std::list&lt;word&gt;&amp; get_retokenizable() <span class="keyword">const</span>;
<a name="l00098"></a>00098 
<a name="l00099"></a>00099     <span class="keyword">const</span> std::list&lt;std::pair&lt;std::wstring,double&gt; &gt; &amp; get_senses() <span class="keyword">const</span>;
<a name="l00100"></a>00100     std::list&lt;std::pair&lt;std::wstring,double&gt; &gt; &amp; get_senses();
<a name="l00101"></a>00101     <span class="keywordtype">void</span> set_senses(<span class="keyword">const</span> std::list&lt;std::pair&lt;std::wstring,double&gt; &gt; &amp;);
<a name="l00102"></a>00102     <span class="comment">// useful for java API</span>
<a name="l00103"></a>00103     std::wstring get_senses_string() <span class="keyword">const</span>;
<a name="l00104"></a>00104 
<a name="l00105"></a>00105     <span class="comment">// get the largest kbest sequence index the analysis is selected in.</span>
<a name="l00106"></a>00106     <span class="keywordtype">int</span> max_kbest() <span class="keyword">const</span>;
<a name="l00107"></a>00107     <span class="comment">// find out whether the analysis is selected in the tagger k-th best sequence</span>
<a name="l00108"></a>00108     <span class="keywordtype">bool</span> is_selected(<span class="keywordtype">int</span> k=0) <span class="keyword">const</span>;
<a name="l00109"></a>00109     <span class="comment">// mark this analysis as selected in k-th best sequence</span>
<a name="l00110"></a>00110     <span class="keywordtype">void</span> mark_selected(<span class="keywordtype">int</span> k=0);
<a name="l00111"></a>00111     <span class="comment">// unmark this analysis as selected in k-th best sequence</span>
<a name="l00112"></a>00112     <span class="keywordtype">void</span> unmark_selected(<span class="keywordtype">int</span> k=0);
<a name="l00113"></a>00113 
<a name="l00115"></a>00115     <span class="keywordtype">bool</span> operator&gt;(<span class="keyword">const</span> <a class="code" href="classfreeling_1_1analysis.html" title="Class analysis stores a possible reading (lemma, PoS, probability, distance) for a word...">analysis</a> &amp;) <span class="keyword">const</span>;
<a name="l00117"></a>00117     <span class="keywordtype">bool</span> operator&lt;(<span class="keyword">const</span> <a class="code" href="classfreeling_1_1analysis.html" title="Class analysis stores a possible reading (lemma, PoS, probability, distance) for a word...">analysis</a> &amp;) <span class="keyword">const</span>;
<a name="l00119"></a>00119     <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> <a class="code" href="classfreeling_1_1analysis.html" title="Class analysis stores a possible reading (lemma, PoS, probability, distance) for a word...">analysis</a> &amp;) <span class="keyword">const</span>;
<a name="l00120"></a>00120   };
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 
<a name="l00127"></a>00127 
<a name="l00128"></a><a class="code" href="classfreeling_1_1word.html">00128</a>   <span class="keyword">class </span>WINDLL <a class="code" href="classfreeling_1_1word.html" title="Class word stores all info related to a word: form, list of analysis, list of tokens (if multiword)...">word</a> : <span class="keyword">public</span> std::<a class="code" href="classstd_1_1list.html">list</a>&lt;analysis&gt; {
<a name="l00129"></a>00129   <span class="keyword">private</span>:
<a name="l00131"></a><a class="code" href="classfreeling_1_1word.html#a9825501c888b59431910723950f3ad67">00131</a>     std::wstring <a class="code" href="classfreeling_1_1word.html#a9825501c888b59431910723950f3ad67" title="lexical form">form</a>;
<a name="l00133"></a><a class="code" href="classfreeling_1_1word.html#ad411c87ea84798306fe537507e25fe06">00133</a>     std::wstring <a class="code" href="classfreeling_1_1word.html#ad411c87ea84798306fe537507e25fe06" title="lexical form, lowercased">lc_form</a>;
<a name="l00135"></a><a class="code" href="classfreeling_1_1word.html#af6014df3f9a01ff123279a372aa1a4fc">00135</a>     std::wstring <a class="code" href="classfreeling_1_1word.html#af6014df3f9a01ff123279a372aa1a4fc" title="phonetic form">ph_form</a>;
<a name="l00137"></a><a class="code" href="classfreeling_1_1word.html#aefc2f8ccca9181ac8fe5620951cef878">00137</a>     std::list&lt;word&gt; <a class="code" href="classfreeling_1_1word.html#aefc2f8ccca9181ac8fe5620951cef878" title="empty list if not a multiword">multiword</a>;
<a name="l00139"></a><a class="code" href="classfreeling_1_1word.html#aa07febb2a010711598373eda574999a0">00139</a>     <span class="keywordtype">bool</span> <a class="code" href="classfreeling_1_1word.html#aa07febb2a010711598373eda574999a0" title="whether the multiword presents segmentantion ambiguity (i.e. could not be a mw)">ambiguous_mw</a>;
<a name="l00141"></a><a class="code" href="classfreeling_1_1word.html#ab8d764ecffa79019ad5b955b201bf8b6">00141</a>     std::list&lt;std::pair&lt;std::wstring,int&gt; &gt; <a class="code" href="classfreeling_1_1word.html#ab8d764ecffa79019ad5b955b201bf8b6" title="alternative forms provided by orthographic or phonetic SED">alternatives</a>;
<a name="l00143"></a><a class="code" href="classfreeling_1_1word.html#ada12b7ae2ea7a22ecad7da2831d88d22">00143</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="classfreeling_1_1word.html#ada12b7ae2ea7a22ecad7da2831d88d22" title="token span">start</a>, finish;
<a name="l00145"></a><a class="code" href="classfreeling_1_1word.html#aad6390283c811380fd640e79a4adcc3f">00145</a>     <span class="keywordtype">bool</span> <a class="code" href="classfreeling_1_1word.html#aad6390283c811380fd640e79a4adcc3f" title="word form found in dictionary">in_dict</a>;
<a name="l00147"></a><a class="code" href="classfreeling_1_1word.html#aea7c5b9ef821def9aaf04af785b1c910">00147</a>     <span class="keywordtype">bool</span> <a class="code" href="classfreeling_1_1word.html#aea7c5b9ef821def9aaf04af785b1c910" title="word morphological shouldn&#39;t be further modified">locked</a>;
<a name="l00149"></a>00149     <span class="keywordtype">void</span> clone(<span class="keyword">const</span> <a class="code" href="classfreeling_1_1word.html" title="Class word stores all info related to a word: form, list of analysis, list of tokens (if multiword)...">word</a> &amp;);
<a name="l00151"></a><a class="code" href="classfreeling_1_1word.html#a491211d3107d08aa1aec2279fb5a216d">00151</a>     <span class="keywordtype">size_t</span> <a class="code" href="classfreeling_1_1word.html#a491211d3107d08aa1aec2279fb5a216d" title="position of word in the sentence (count from 0)">position</a>;
<a name="l00152"></a>00152  
<a name="l00154"></a><a class="code" href="classfreeling_1_1word.html#a1d954492f25448f6bd07029826c7aa69">00154</a>     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> SELECTED=0;
<a name="l00155"></a><a class="code" href="classfreeling_1_1word.html#a62528dd7cdfa57fb768ae5b1a62d2633">00155</a>     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> UNSELECTED=1;
<a name="l00156"></a><a class="code" href="classfreeling_1_1word.html#a8edf938a11fcb40503644c27c7c91837">00156</a>     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> ALL=2;
<a name="l00157"></a>00157 
<a name="l00158"></a>00158   <span class="keyword">public</span>:
<a name="l00159"></a>00159     <span class="comment">// predeclarations</span>
<a name="l00160"></a>00160     <span class="keyword">class </span><a class="code" href="classfreeling_1_1word_1_1iterator.html" title="iterator over word analysis (either all, only selected, only unselected)">iterator</a>; 
<a name="l00161"></a><a class="code" href="classfreeling_1_1word.html#af26c0cb69942b7af32ab07e644047ef8">00161</a>     <span class="keyword">class </span><a class="code" href="classfreeling_1_1word_1_1const__iterator.html" title="const_iterator over word analysis (either all, only selected, only unselected)">const_iterator</a>; 
<a name="l00162"></a>00162 
<a name="l00164"></a>00164     std::vector&lt;std::wstring&gt; <a class="code" href="classfreeling_1_1word.html#af26c0cb69942b7af32ab07e644047ef8" title="user-managed data, we just store it.">user</a>;
<a name="l00165"></a>00165 
<a name="l00167"></a>00167     <a class="code" href="classfreeling_1_1word.html" title="Class word stores all info related to a word: form, list of analysis, list of tokens (if multiword)...">word</a>();
<a name="l00169"></a>00169     <a class="code" href="classfreeling_1_1word.html" title="Class word stores all info related to a word: form, list of analysis, list of tokens (if multiword)...">word</a>(<span class="keyword">const</span> std::wstring &amp;);
<a name="l00171"></a>00171     <a class="code" href="classfreeling_1_1word.html" title="Class word stores all info related to a word: form, list of analysis, list of tokens (if multiword)...">word</a>(<span class="keyword">const</span> std::wstring &amp;, <span class="keyword">const</span> std::list&lt;word&gt; &amp;);
<a name="l00173"></a>00173     <a class="code" href="classfreeling_1_1word.html" title="Class word stores all info related to a word: form, list of analysis, list of tokens (if multiword)...">word</a>(<span class="keyword">const</span> std::wstring &amp;, <span class="keyword">const</span> std::list&lt;analysis&gt; &amp;, <span class="keyword">const</span> std::list&lt;word&gt; &amp;);
<a name="l00175"></a>00175     <a class="code" href="classfreeling_1_1word.html" title="Class word stores all info related to a word: form, list of analysis, list of tokens (if multiword)...">word</a>(<span class="keyword">const</span> <a class="code" href="classfreeling_1_1word.html" title="Class word stores all info related to a word: form, list of analysis, list of tokens (if multiword)...">word</a> &amp;);
<a name="l00177"></a>00177     <a class="code" href="classfreeling_1_1word.html" title="Class word stores all info related to a word: form, list of analysis, list of tokens (if multiword)...">word</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classfreeling_1_1word.html" title="Class word stores all info related to a word: form, list of analysis, list of tokens (if multiword)...">word</a>&amp;);
<a name="l00178"></a>00178 
<a name="l00180"></a>00180     <span class="keywordtype">void</span> copy_analysis(<span class="keyword">const</span> <a class="code" href="classfreeling_1_1word.html" title="Class word stores all info related to a word: form, list of analysis, list of tokens (if multiword)...">word</a> &amp;);
<a name="l00182"></a>00182     <span class="keywordtype">int</span> get_n_selected(<span class="keywordtype">int</span> k=0) <span class="keyword">const</span>;
<a name="l00184"></a>00184     <span class="keywordtype">int</span> get_n_unselected(<span class="keywordtype">int</span> k=0) <span class="keyword">const</span>;
<a name="l00186"></a>00186     <span class="keywordtype">bool</span> is_multiword() <span class="keyword">const</span>;
<a name="l00188"></a>00188     <span class="keywordtype">bool</span> is_ambiguous_mw() <span class="keyword">const</span>;
<a name="l00190"></a>00190     <span class="keywordtype">void</span> set_ambiguous_mw(<span class="keywordtype">bool</span>);
<a name="l00192"></a>00192     <span class="keywordtype">int</span> get_n_words_mw() <span class="keyword">const</span>;
<a name="l00194"></a>00194     <span class="keyword">const</span> std::list&lt;word&gt;&amp; get_words_mw() <span class="keyword">const</span>;
<a name="l00196"></a>00196     std::wstring get_form() <span class="keyword">const</span>;
<a name="l00198"></a>00198     std::wstring get_lc_form() <span class="keyword">const</span>;
<a name="l00200"></a>00200     std::wstring get_ph_form() <span class="keyword">const</span>;
<a name="l00202"></a>00202     <a class="code" href="classfreeling_1_1word_1_1iterator.html" title="iterator over word analysis (either all, only selected, only unselected)">word::iterator</a> selected_begin(<span class="keywordtype">int</span> k=0);
<a name="l00204"></a>00204     <a class="code" href="classfreeling_1_1word_1_1const__iterator.html" title="const_iterator over word analysis (either all, only selected, only unselected)">word::const_iterator</a> selected_begin(<span class="keywordtype">int</span> k=0) <span class="keyword">const</span>;
<a name="l00206"></a>00206     <a class="code" href="classfreeling_1_1word_1_1iterator.html" title="iterator over word analysis (either all, only selected, only unselected)">word::iterator</a> selected_end(<span class="keywordtype">int</span> k=0);
<a name="l00208"></a>00208     <a class="code" href="classfreeling_1_1word_1_1const__iterator.html" title="const_iterator over word analysis (either all, only selected, only unselected)">word::const_iterator</a> selected_end(<span class="keywordtype">int</span> k=0) <span class="keyword">const</span>;
<a name="l00210"></a>00210     <a class="code" href="classfreeling_1_1word_1_1iterator.html" title="iterator over word analysis (either all, only selected, only unselected)">word::iterator</a> unselected_begin(<span class="keywordtype">int</span> k=0);
<a name="l00212"></a>00212     <a class="code" href="classfreeling_1_1word_1_1const__iterator.html" title="const_iterator over word analysis (either all, only selected, only unselected)">word::const_iterator</a> unselected_begin(<span class="keywordtype">int</span> k=0) <span class="keyword">const</span>;
<a name="l00214"></a>00214     <a class="code" href="classfreeling_1_1word_1_1iterator.html" title="iterator over word analysis (either all, only selected, only unselected)">word::iterator</a> unselected_end(<span class="keywordtype">int</span> k=0);
<a name="l00216"></a>00216     <a class="code" href="classfreeling_1_1word_1_1const__iterator.html" title="const_iterator over word analysis (either all, only selected, only unselected)">word::const_iterator</a> unselected_end(<span class="keywordtype">int</span> k=0) <span class="keyword">const</span>;
<a name="l00218"></a>00218     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_kbest() <span class="keyword">const</span>;
<a name="l00220"></a>00220     std::wstring get_lemma(<span class="keywordtype">int</span> k=0) <span class="keyword">const</span>;
<a name="l00222"></a>00222     std::wstring get_tag(<span class="keywordtype">int</span> k=0) <span class="keyword">const</span>;
<a name="l00224"></a>00224     std::wstring get_short_tag(<span class="keywordtype">int</span> k=0) <span class="keyword">const</span>;
<a name="l00226"></a>00226     std::wstring get_short_tag(<span class="keyword">const</span> std::wstring &amp;,<span class="keywordtype">int</span> k=0) <span class="keyword">const</span>;
<a name="l00227"></a>00227 
<a name="l00229"></a>00229     <span class="keyword">const</span> std::list&lt;std::pair&lt;std::wstring,double&gt; &gt;&amp; get_senses(<span class="keywordtype">int</span> k=0) <span class="keyword">const</span>;
<a name="l00230"></a>00230     std::list&lt;std::pair&lt;std::wstring,double&gt; &gt;&amp; get_senses(<span class="keywordtype">int</span> k=0);
<a name="l00231"></a>00231     <span class="comment">// useful for java API</span>
<a name="l00232"></a>00232     std::wstring get_senses_string(<span class="keywordtype">int</span> k=0) <span class="keyword">const</span>;
<a name="l00234"></a>00234     <span class="keywordtype">void</span> set_senses(<span class="keyword">const</span> std::list&lt;std::pair&lt;std::wstring,double&gt; &gt; &amp;, <span class="keywordtype">int</span> k=0);
<a name="l00235"></a>00235 
<a name="l00237"></a>00237     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> get_span_start() <span class="keyword">const</span>;
<a name="l00238"></a>00238     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> get_span_finish() <span class="keyword">const</span>;
<a name="l00239"></a>00239 
<a name="l00241"></a>00241     <span class="keywordtype">bool</span> found_in_dict() <span class="keyword">const</span>;
<a name="l00243"></a>00243     <span class="keywordtype">void</span> set_found_in_dict(<span class="keywordtype">bool</span>);
<a name="l00245"></a>00245     <span class="keywordtype">bool</span> has_retokenizable() <span class="keyword">const</span>;
<a name="l00247"></a>00247     <span class="keywordtype">void</span> lock_analysis();
<a name="l00249"></a>00249     <span class="keywordtype">bool</span> is_locked() <span class="keyword">const</span>;
<a name="l00250"></a>00250 
<a name="l00252"></a>00252     <span class="keywordtype">void</span> add_alternative(<span class="keyword">const</span> std::wstring &amp;, <span class="keywordtype">int</span>);
<a name="l00254"></a>00254     <span class="keywordtype">void</span> set_alternatives(<span class="keyword">const</span> std::list&lt;std::pair&lt;std::wstring,int&gt; &gt; &amp;);
<a name="l00256"></a>00256     <span class="keywordtype">void</span> clear_alternatives();
<a name="l00258"></a>00258     <span class="keywordtype">bool</span> has_alternatives() <span class="keyword">const</span>;
<a name="l00260"></a>00260     <span class="keyword">const</span> std::list&lt;std::pair&lt;std::wstring,int&gt; &gt;&amp; get_alternatives() <span class="keyword">const</span>;
<a name="l00262"></a>00262     std::list&lt;std::pair&lt;std::wstring,int&gt; &gt;&amp; get_alternatives();
<a name="l00264"></a>00264     std::list&lt;std::pair&lt;std::wstring,int&gt; &gt;<a class="code" href="classfreeling_1_1word_1_1iterator.html" title="iterator over word analysis (either all, only selected, only unselected)">::iterator</a> alternatives_begin();
<a name="l00266"></a>00266     std::list&lt;std::pair&lt;std::wstring,int&gt; &gt;<a class="code" href="classfreeling_1_1word_1_1iterator.html" title="iterator over word analysis (either all, only selected, only unselected)">::iterator</a> alternatives_end();
<a name="l00268"></a>00268     std::list&lt;std::pair&lt;std::wstring,int&gt; &gt;<a class="code" href="classfreeling_1_1word_1_1const__iterator.html" title="const_iterator over word analysis (either all, only selected, only unselected)">::const_iterator</a> alternatives_begin() <span class="keyword">const</span>;
<a name="l00270"></a>00270     std::list&lt;std::pair&lt;std::wstring,int&gt; &gt;<a class="code" href="classfreeling_1_1word_1_1const__iterator.html" title="const_iterator over word analysis (either all, only selected, only unselected)">::const_iterator</a> alternatives_end() <span class="keyword">const</span>;
<a name="l00271"></a>00271 
<a name="l00273"></a>00273     <span class="keywordtype">void</span> add_analysis(<span class="keyword">const</span> <a class="code" href="classfreeling_1_1analysis.html" title="Class analysis stores a possible reading (lemma, PoS, probability, distance) for a word...">analysis</a> &amp;);
<a name="l00275"></a>00275     <span class="keywordtype">void</span> set_analysis(<span class="keyword">const</span> <a class="code" href="classfreeling_1_1analysis.html" title="Class analysis stores a possible reading (lemma, PoS, probability, distance) for a word...">analysis</a> &amp;);
<a name="l00277"></a>00277     <span class="keywordtype">void</span> set_analysis(<span class="keyword">const</span> std::list&lt;analysis&gt; &amp;);
<a name="l00279"></a>00279     <span class="keywordtype">void</span> set_form(<span class="keyword">const</span> std::wstring &amp;);
<a name="l00281"></a>00281     <span class="keywordtype">void</span> set_ph_form(<span class="keyword">const</span> std::wstring &amp;);
<a name="l00283"></a>00283     <span class="keywordtype">void</span> set_span(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>);
<a name="l00284"></a>00284 
<a name="l00285"></a>00285     <span class="comment">// get/set word position</span>
<a name="l00286"></a>00286     <span class="keywordtype">void</span> set_position(<span class="keywordtype">size_t</span>);
<a name="l00287"></a>00287     <span class="keywordtype">size_t</span> get_position() <span class="keyword">const</span>;
<a name="l00288"></a>00288 
<a name="l00290"></a>00290     <span class="keywordtype">bool</span> find_tag_match(<span class="keyword">const</span> <a class="code" href="classfreeling_1_1regexp.html">freeling::regexp</a> &amp;) <span class="keyword">const</span>;
<a name="l00291"></a>00291 
<a name="l00293"></a>00293     <span class="keywordtype">int</span> get_n_analysis() <span class="keyword">const</span>;
<a name="l00295"></a>00295     <span class="keywordtype">void</span> unselect_all_analysis(<span class="keywordtype">int</span> k=0);
<a name="l00297"></a>00297     <span class="keywordtype">void</span> select_all_analysis(<span class="keywordtype">int</span> k=0);
<a name="l00299"></a>00299     <span class="keywordtype">void</span> select_analysis(<a class="code" href="classfreeling_1_1word_1_1iterator.html" title="iterator over word analysis (either all, only selected, only unselected)">word::iterator</a>, <span class="keywordtype">int</span> k=0);
<a name="l00301"></a>00301     <span class="keywordtype">void</span> unselect_analysis(<a class="code" href="classfreeling_1_1word_1_1iterator.html" title="iterator over word analysis (either all, only selected, only unselected)">word::iterator</a>, <span class="keywordtype">int</span> k=0);
<a name="l00303"></a>00303     std::list&lt;analysis&gt; get_analysis() <span class="keyword">const</span>;
<a name="l00305"></a>00305     <a class="code" href="classfreeling_1_1word_1_1iterator.html" title="iterator over word analysis (either all, only selected, only unselected)">word::iterator</a> analysis_begin();
<a name="l00306"></a>00306     <a class="code" href="classfreeling_1_1word_1_1const__iterator.html" title="const_iterator over word analysis (either all, only selected, only unselected)">word::const_iterator</a> analysis_begin() <span class="keyword">const</span>;
<a name="l00308"></a>00308     <a class="code" href="classfreeling_1_1word_1_1iterator.html" title="iterator over word analysis (either all, only selected, only unselected)">word::iterator</a> analysis_end();
<a name="l00309"></a>00309     <a class="code" href="classfreeling_1_1word_1_1const__iterator.html" title="const_iterator over word analysis (either all, only selected, only unselected)">word::const_iterator</a> analysis_end() <span class="keyword">const</span>;
<a name="l00310"></a>00310 
<a name="l00312"></a><a class="code" href="classfreeling_1_1word_1_1iterator.html">00312</a>     <span class="keyword">class </span>WINDLL <a class="code" href="classfreeling_1_1word_1_1iterator.html" title="iterator over word analysis (either all, only selected, only unselected)">iterator</a> : <span class="keyword">public</span> std::<a class="code" href="classstd_1_1list.html">list</a>&lt;analysis&gt;::<a class="code" href="classfreeling_1_1word_1_1iterator.html" title="iterator over word analysis (either all, only selected, only unselected)">iterator</a> {
<a name="l00313"></a><a class="code" href="classfreeling_1_1word_1_1iterator.html#af7fe44e0a450085fbafb1d04a5f6b635">00313</a>       <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classfreeling_1_1word_1_1const__iterator.html" title="const_iterator over word analysis (either all, only selected, only unselected)">word::const_iterator</a>;
<a name="l00314"></a>00314     <span class="keyword">private</span>:
<a name="l00316"></a><a class="code" href="classfreeling_1_1word_1_1iterator.html#a52506012aa16aa54a7dd73a7e831bf32">00316</a>       std::list&lt;analysis&gt;::iterator <a class="code" href="classfreeling_1_1word_1_1iterator.html#a52506012aa16aa54a7dd73a7e831bf32" title="Iterator range begin.">ibeg</a>;
<a name="l00318"></a><a class="code" href="classfreeling_1_1word_1_1iterator.html#af9393c2bb3ee65935698eceab8afc80f">00318</a>       std::list&lt;analysis&gt;::iterator <a class="code" href="classfreeling_1_1word_1_1iterator.html#af9393c2bb3ee65935698eceab8afc80f" title="Iterator range end.">iend</a>;
<a name="l00320"></a><a class="code" href="classfreeling_1_1word_1_1iterator.html#a7cbbe72c53d14bfb8deb52ac64cea241">00320</a>       <span class="keywordtype">int</span> <a class="code" href="classfreeling_1_1word_1_1iterator.html#a7cbbe72c53d14bfb8deb52ac64cea241" title="Iterator type (ALL,SELECTED,UNSELECTED)">type</a>;
<a name="l00322"></a><a class="code" href="classfreeling_1_1word_1_1iterator.html#a21f6b2f41d32aef1ec0ffc8b7ecf7a67">00322</a>       <span class="keywordtype">int</span> <a class="code" href="classfreeling_1_1word_1_1iterator.html#a21f6b2f41d32aef1ec0ffc8b7ecf7a67" title="Which of k-best sequences proposed by the tagger is the iterator associated with.">kbest</a>;
<a name="l00323"></a>00323 
<a name="l00324"></a>00324     <span class="keyword">public</span>:
<a name="l00326"></a>00326       <a class="code" href="classfreeling_1_1word_1_1iterator.html" title="iterator over word analysis (either all, only selected, only unselected)">iterator</a>();
<a name="l00328"></a>00328       <a class="code" href="classfreeling_1_1word_1_1iterator.html" title="iterator over word analysis (either all, only selected, only unselected)">iterator</a>(<span class="keyword">const</span> <a class="code" href="classfreeling_1_1word_1_1iterator.html" title="iterator over word analysis (either all, only selected, only unselected)">word::iterator</a> &amp;);
<a name="l00330"></a>00330       <a class="code" href="classfreeling_1_1word_1_1iterator.html" title="iterator over word analysis (either all, only selected, only unselected)">iterator</a>(<span class="keyword">const</span> std::list&lt;analysis&gt;::iterator &amp;);
<a name="l00332"></a>00332       <a class="code" href="classfreeling_1_1word_1_1iterator.html" title="iterator over word analysis (either all, only selected, only unselected)">iterator</a>(<span class="keyword">const</span> std::list&lt;analysis&gt;::iterator &amp;, 
<a name="l00333"></a>00333                <span class="keyword">const</span> std::list&lt;analysis&gt;::iterator &amp;, 
<a name="l00334"></a>00334                <span class="keyword">const</span> std::list&lt;analysis&gt;::iterator &amp;, <span class="keywordtype">int</span>,<span class="keywordtype">int</span> k=0);  
<a name="l00336"></a>00336       <a class="code" href="classfreeling_1_1word_1_1iterator.html" title="iterator over word analysis (either all, only selected, only unselected)">iterator</a>&amp; operator++();
<a name="l00337"></a>00337       <a class="code" href="classfreeling_1_1word_1_1iterator.html" title="iterator over word analysis (either all, only selected, only unselected)">iterator</a> operator++(<span class="keywordtype">int</span>);
<a name="l00338"></a>00338     };
<a name="l00339"></a>00339   
<a name="l00341"></a><a class="code" href="classfreeling_1_1word_1_1const__iterator.html">00341</a>     <span class="keyword">class </span>WINDLL <a class="code" href="classfreeling_1_1word_1_1const__iterator.html" title="const_iterator over word analysis (either all, only selected, only unselected)">const_iterator</a> : <span class="keyword">public</span> std::<a class="code" href="classstd_1_1list.html">list</a>&lt;analysis&gt;::<a class="code" href="classfreeling_1_1word_1_1const__iterator.html" title="const_iterator over word analysis (either all, only selected, only unselected)">const_iterator</a> {
<a name="l00342"></a>00342     <span class="keyword">private</span>:
<a name="l00344"></a><a class="code" href="classfreeling_1_1word_1_1const__iterator.html#a921b2c292e92311b19c1feb3a365840f">00344</a>       std::list&lt;analysis&gt;::const_iterator <a class="code" href="classfreeling_1_1word_1_1const__iterator.html#a921b2c292e92311b19c1feb3a365840f" title="Iterator range begin.">ibeg</a>;
<a name="l00346"></a><a class="code" href="classfreeling_1_1word_1_1const__iterator.html#a497fc46f09d24ec4d658abeaf9a01f94">00346</a>       std::list&lt;analysis&gt;::const_iterator <a class="code" href="classfreeling_1_1word_1_1const__iterator.html#a497fc46f09d24ec4d658abeaf9a01f94" title="Iterator range end.">iend</a>;
<a name="l00348"></a><a class="code" href="classfreeling_1_1word_1_1const__iterator.html#a628c75ebfa503caa9404223191e0872c">00348</a>       <span class="keywordtype">int</span> <a class="code" href="classfreeling_1_1word_1_1const__iterator.html#a628c75ebfa503caa9404223191e0872c" title="Iterator type (ALL,SELECTED,UNSELECTED)">type</a>;
<a name="l00350"></a><a class="code" href="classfreeling_1_1word_1_1const__iterator.html#a1870ce69396d6609ddb973929ddbd0bf">00350</a>       <span class="keywordtype">int</span> <a class="code" href="classfreeling_1_1word_1_1const__iterator.html#a1870ce69396d6609ddb973929ddbd0bf" title="Which of k-best sequences proposed by the tagger is the iterator associated with.">kbest</a>;
<a name="l00351"></a>00351 
<a name="l00352"></a>00352     <span class="keyword">public</span>:
<a name="l00354"></a>00354       <a class="code" href="classfreeling_1_1word_1_1const__iterator.html" title="const_iterator over word analysis (either all, only selected, only unselected)">const_iterator</a>();
<a name="l00356"></a>00356       <a class="code" href="classfreeling_1_1word_1_1const__iterator.html" title="const_iterator over word analysis (either all, only selected, only unselected)">const_iterator</a>(<span class="keyword">const</span> <a class="code" href="classfreeling_1_1word_1_1const__iterator.html" title="const_iterator over word analysis (either all, only selected, only unselected)">word::const_iterator</a> &amp;);
<a name="l00358"></a>00358       <a class="code" href="classfreeling_1_1word_1_1const__iterator.html" title="const_iterator over word analysis (either all, only selected, only unselected)">const_iterator</a>(<span class="keyword">const</span> <a class="code" href="classfreeling_1_1word_1_1iterator.html" title="iterator over word analysis (either all, only selected, only unselected)">word::iterator</a> &amp;);
<a name="l00360"></a>00360       <a class="code" href="classfreeling_1_1word_1_1const__iterator.html" title="const_iterator over word analysis (either all, only selected, only unselected)">const_iterator</a>(<span class="keyword">const</span> std::list&lt;analysis&gt;::const_iterator &amp;);
<a name="l00362"></a>00362       <a class="code" href="classfreeling_1_1word_1_1const__iterator.html" title="const_iterator over word analysis (either all, only selected, only unselected)">const_iterator</a>(<span class="keyword">const</span> std::list&lt;analysis&gt;::iterator &amp;);
<a name="l00364"></a>00364       <a class="code" href="classfreeling_1_1word_1_1const__iterator.html" title="const_iterator over word analysis (either all, only selected, only unselected)">const_iterator</a>(<span class="keyword">const</span> std::list&lt;analysis&gt;::const_iterator &amp;,
<a name="l00365"></a>00365                      <span class="keyword">const</span> std::list&lt;analysis&gt;::const_iterator &amp;, 
<a name="l00366"></a>00366                      <span class="keyword">const</span> std::list&lt;analysis&gt;::const_iterator &amp;, <span class="keywordtype">int</span>, <span class="keywordtype">int</span> k=0);
<a name="l00368"></a>00368       <a class="code" href="classfreeling_1_1word_1_1const__iterator.html" title="const_iterator over word analysis (either all, only selected, only unselected)">const_iterator</a>&amp; operator++();  
<a name="l00369"></a>00369       <a class="code" href="classfreeling_1_1word_1_1const__iterator.html" title="const_iterator over word analysis (either all, only selected, only unselected)">const_iterator</a> operator++(<span class="keywordtype">int</span>);  
<a name="l00370"></a>00370     };
<a name="l00371"></a>00371 
<a name="l00372"></a>00372   };
<a name="l00373"></a>00373 
<a name="l00374"></a>00374 
<a name="l00375"></a>00375 
<a name="l00381"></a>00381 
<a name="l00382"></a><a class="code" href="classfreeling_1_1node.html">00382</a>   <span class="keyword">class </span>WINDLL <a class="code" href="classfreeling_1_1node.html" title="Class node stores nodes of a parse_tree Each node in the tree is either a label (intermediate node) o...">node</a> {
<a name="l00383"></a>00383   <span class="keyword">protected</span>:
<a name="l00385"></a><a class="code" href="classfreeling_1_1node.html#a533f3f47a1bffeb848b80d48bac06dba">00385</a>     std::wstring <a class="code" href="classfreeling_1_1node.html#a533f3f47a1bffeb848b80d48bac06dba" title="node identifier">nodeid</a>;
<a name="l00387"></a><a class="code" href="classfreeling_1_1node.html#a3e5635533929320bd39f93deedb84029">00387</a>     <span class="keywordtype">bool</span> <a class="code" href="classfreeling_1_1node.html#a3e5635533929320bd39f93deedb84029" title="is the node the head of the rule?">head</a>;
<a name="l00389"></a><a class="code" href="classfreeling_1_1node.html#ad8f3b5977a9c39448b669b89815fa024">00389</a>     <span class="keywordtype">int</span> <a class="code" href="classfreeling_1_1node.html#ad8f3b5977a9c39448b669b89815fa024" title="is the node the root of a chunk? which?">chunk</a>;
<a name="l00391"></a><a class="code" href="classfreeling_1_1node.html#a6593909fbe9bd9a34f46cae6596177e7">00391</a>     std::wstring <a class="code" href="classfreeling_1_1node.html#a6593909fbe9bd9a34f46cae6596177e7" title="node label">label</a>;
<a name="l00393"></a><a class="code" href="classfreeling_1_1node.html#a6c0fddce036ddf736a26f9cc6c2ca4a4">00393</a>     <a class="code" href="classfreeling_1_1word.html" title="Class word stores all info related to a word: form, list of analysis, list of tokens (if multiword)...">word</a> * <a class="code" href="classfreeling_1_1node.html#a6c0fddce036ddf736a26f9cc6c2ca4a4" title="sentence word related to the node (if leaf)">w</a>;
<a name="l00394"></a>00394 
<a name="l00395"></a>00395   <span class="keyword">public</span>:
<a name="l00397"></a><a class="code" href="classfreeling_1_1node.html#a0cfaac2c2da3798ec8dd0a1fb08a8fca">00397</a>     std::vector&lt;std::wstring&gt; <a class="code" href="classfreeling_1_1node.html#a0cfaac2c2da3798ec8dd0a1fb08a8fca" title="user-managed data, we just store it.">user</a>;
<a name="l00398"></a>00398 
<a name="l00400"></a>00400     <a class="code" href="classfreeling_1_1node.html" title="Class node stores nodes of a parse_tree Each node in the tree is either a label (intermediate node) o...">node</a>();
<a name="l00401"></a>00401     <a class="code" href="classfreeling_1_1node.html" title="Class node stores nodes of a parse_tree Each node in the tree is either a label (intermediate node) o...">node</a>(<span class="keyword">const</span> std::wstring &amp;);
<a name="l00403"></a>00403     std::wstring get_node_id() <span class="keyword">const</span>;
<a name="l00405"></a>00405     <span class="keywordtype">void</span> set_node_id(<span class="keyword">const</span> std::wstring &amp;);
<a name="l00407"></a>00407     std::wstring get_label() <span class="keyword">const</span>;
<a name="l00409"></a>00409     <span class="keyword">const</span> <a class="code" href="classfreeling_1_1word.html" title="Class word stores all info related to a word: form, list of analysis, list of tokens (if multiword)...">word</a> &amp; get_word() <span class="keyword">const</span>;
<a name="l00411"></a>00411     <a class="code" href="classfreeling_1_1word.html" title="Class word stores all info related to a word: form, list of analysis, list of tokens (if multiword)...">word</a> &amp; get_word();
<a name="l00413"></a>00413     <span class="keywordtype">void</span> set_label(<span class="keyword">const</span> std::wstring &amp;);
<a name="l00415"></a>00415     <span class="keywordtype">void</span> set_word(<a class="code" href="classfreeling_1_1word.html" title="Class word stores all info related to a word: form, list of analysis, list of tokens (if multiword)...">word</a> &amp;);
<a name="l00417"></a>00417     <span class="keywordtype">bool</span> is_head() <span class="keyword">const</span>;
<a name="l00419"></a>00419     <span class="keywordtype">void</span> set_head(<span class="keyword">const</span> <span class="keywordtype">bool</span>);
<a name="l00421"></a>00421     <span class="keywordtype">bool</span> is_chunk() <span class="keyword">const</span>;
<a name="l00423"></a>00423     <span class="keywordtype">void</span> set_chunk(<span class="keyword">const</span> <span class="keywordtype">int</span>);
<a name="l00425"></a>00425     <span class="keywordtype">int</span>  get_chunk_ord() <span class="keyword">const</span>;
<a name="l00426"></a>00426 
<a name="l00427"></a>00427   };
<a name="l00428"></a>00428 
<a name="l00432"></a>00432 
<a name="l00433"></a><a class="code" href="classfreeling_1_1parse__tree.html">00433</a>   <span class="keyword">class </span>WINDLL <a class="code" href="classfreeling_1_1parse__tree.html" title="Class parse tree is used to store the results of parsing.">parse_tree</a> : <span class="keyword">public</span> <a class="code" href="classfreeling_1_1tree.html">tree</a>&lt;node&gt; {
<a name="l00434"></a>00434   <span class="keyword">private</span>:
<a name="l00435"></a>00435     <span class="comment">// access nodes by id</span>
<a name="l00436"></a><a class="code" href="classfreeling_1_1parse__tree.html#a7e758a2e53b1a40ce9ea1490e9d46424">00436</a>     std::map&lt;std::wstring,parse_tree::iterator&gt; <a class="code" href="classfreeling_1_1parse__tree.html#a7e758a2e53b1a40ce9ea1490e9d46424">node_index</a>;
<a name="l00437"></a>00437     <span class="comment">// acces leaf nodes by word position</span>
<a name="l00438"></a><a class="code" href="classfreeling_1_1parse__tree.html#acc5f38401285f11d27ee6edd70549c40">00438</a>     std::vector&lt;parse_tree::iterator&gt; <a class="code" href="classfreeling_1_1parse__tree.html#acc5f38401285f11d27ee6edd70549c40">word_index</a>;
<a name="l00439"></a>00439 
<a name="l00440"></a>00440   <span class="keyword">public</span>:
<a name="l00441"></a>00441     <a class="code" href="classfreeling_1_1parse__tree.html" title="Class parse tree is used to store the results of parsing.">parse_tree</a>();
<a name="l00442"></a>00442     <a class="code" href="classfreeling_1_1parse__tree.html" title="Class parse tree is used to store the results of parsing.">parse_tree</a>(<a class="code" href="classfreeling_1_1tree.html#a5ba0306fd7e58c12de8a6d148d7dadbb">parse_tree::iterator</a> p);
<a name="l00443"></a>00443     <a class="code" href="classfreeling_1_1parse__tree.html" title="Class parse tree is used to store the results of parsing.">parse_tree</a>(<span class="keyword">const</span> <a class="code" href="classfreeling_1_1node.html" title="Class node stores nodes of a parse_tree Each node in the tree is either a label (intermediate node) o...">node</a> &amp;);
<a name="l00444"></a>00444 
<a name="l00446"></a>00446     <span class="keywordtype">void</span> build_node_index(<span class="keyword">const</span> std::wstring &amp;);
<a name="l00448"></a>00448     <span class="keywordtype">void</span> rebuild_node_index();
<a name="l00450"></a>00450     <a class="code" href="classfreeling_1_1tree.html#a5fa3f5c4eb930c9bf9f05b7cba8941ee">parse_tree::const_iterator</a> get_node_by_id(<span class="keyword">const</span> std::wstring &amp;) <span class="keyword">const</span>;
<a name="l00452"></a>00452     <a class="code" href="classfreeling_1_1tree.html#a5fa3f5c4eb930c9bf9f05b7cba8941ee">parse_tree::const_iterator</a> get_node_by_pos(<span class="keywordtype">size_t</span>) <span class="keyword">const</span>;
<a name="l00454"></a>00454     <a class="code" href="classfreeling_1_1tree.html#a5ba0306fd7e58c12de8a6d148d7dadbb">parse_tree::iterator</a> get_node_by_id(<span class="keyword">const</span> std::wstring &amp;);
<a name="l00456"></a>00456     <a class="code" href="classfreeling_1_1tree.html#a5ba0306fd7e58c12de8a6d148d7dadbb">parse_tree::iterator</a> get_node_by_pos(<span class="keywordtype">size_t</span>);
<a name="l00457"></a>00457 
<a name="l00458"></a>00458   };
<a name="l00459"></a>00459 
<a name="l00460"></a>00460 
<a name="l00465"></a>00465 
<a name="l00466"></a><a class="code" href="classfreeling_1_1depnode.html">00466</a>   <span class="keyword">class </span>WINDLL <a class="code" href="classfreeling_1_1depnode.html" title="class denode stores nodes of a dependency tree and parse tree &lt;-&gt; deptree relations">depnode</a> : <span class="keyword">public</span> <a class="code" href="classfreeling_1_1node.html" title="Class node stores nodes of a parse_tree Each node in the tree is either a label (intermediate node) o...">node</a> {
<a name="l00467"></a>00467 
<a name="l00468"></a>00468   <span class="keyword">private</span>:
<a name="l00470"></a><a class="code" href="classfreeling_1_1depnode.html#a2b6fec708c7b4187e159e936907dbc52">00470</a>     <a class="code" href="classfreeling_1_1tree.html#a5ba0306fd7e58c12de8a6d148d7dadbb">parse_tree::iterator</a> <a class="code" href="classfreeling_1_1depnode.html#a2b6fec708c7b4187e159e936907dbc52" title="corresponding node of the parse tree in the same sentence.">link</a>;
<a name="l00471"></a>00471 
<a name="l00472"></a>00472   <span class="keyword">public</span>:
<a name="l00473"></a>00473     <a class="code" href="classfreeling_1_1depnode.html" title="class denode stores nodes of a dependency tree and parse tree &lt;-&gt; deptree relations">depnode</a>();
<a name="l00474"></a>00474     <a class="code" href="classfreeling_1_1depnode.html" title="class denode stores nodes of a dependency tree and parse tree &lt;-&gt; deptree relations">depnode</a>(<span class="keyword">const</span> std::wstring &amp;);
<a name="l00475"></a>00475     <a class="code" href="classfreeling_1_1depnode.html" title="class denode stores nodes of a dependency tree and parse tree &lt;-&gt; deptree relations">depnode</a>(<span class="keyword">const</span> <a class="code" href="classfreeling_1_1node.html" title="Class node stores nodes of a parse_tree Each node in the tree is either a label (intermediate node) o...">node</a> &amp;);
<a name="l00476"></a>00476 
<a name="l00478"></a>00478     <span class="keywordtype">void</span> set_link(<span class="keyword">const</span> <a class="code" href="classfreeling_1_1tree.html#a5ba0306fd7e58c12de8a6d148d7dadbb">parse_tree::iterator</a>);
<a name="l00480"></a>00480     <a class="code" href="classfreeling_1_1tree.html#a5ba0306fd7e58c12de8a6d148d7dadbb">parse_tree::iterator</a> get_link();
<a name="l00481"></a>00481     <a class="code" href="classfreeling_1_1tree.html#a5fa3f5c4eb930c9bf9f05b7cba8941ee">parse_tree::const_iterator</a> get_link() <span class="keyword">const</span>;
<a name="l00483"></a>00483     <a class="code" href="classfreeling_1_1tree.html">tree&lt;node&gt;</a>&amp; get_link_ref();  
<a name="l00484"></a>00484   };
<a name="l00485"></a>00485 
<a name="l00486"></a>00486 
<a name="l00487"></a>00487 
<a name="l00491"></a>00491 
<a name="l00492"></a><a class="code" href="classfreeling_1_1dep__tree.html">00492</a>   <span class="keyword">class </span>WINDLL <a class="code" href="classfreeling_1_1dep__tree.html" title="class dep_tree stores a dependency tree">dep_tree</a> :  <span class="keyword">public</span> <a class="code" href="classfreeling_1_1tree.html">tree</a>&lt;depnode&gt; {
<a name="l00493"></a>00493 
<a name="l00494"></a>00494   <span class="keyword">private</span>:
<a name="l00495"></a>00495     <span class="comment">// acces nodes by word position</span>
<a name="l00496"></a><a class="code" href="classfreeling_1_1dep__tree.html#acd9f88b9a10e343dfa441ea5fc35449a">00496</a>     std::vector&lt;dep_tree::iterator&gt; <a class="code" href="classfreeling_1_1dep__tree.html#acd9f88b9a10e343dfa441ea5fc35449a">word_index</a>;
<a name="l00497"></a>00497 
<a name="l00498"></a>00498   <span class="keyword">public</span>:
<a name="l00499"></a>00499     <a class="code" href="classfreeling_1_1dep__tree.html" title="class dep_tree stores a dependency tree">dep_tree</a>();
<a name="l00500"></a>00500     <a class="code" href="classfreeling_1_1dep__tree.html" title="class dep_tree stores a dependency tree">dep_tree</a>(<span class="keyword">const</span> <a class="code" href="classfreeling_1_1depnode.html" title="class denode stores nodes of a dependency tree and parse tree &lt;-&gt; deptree relations">depnode</a> &amp;);
<a name="l00501"></a>00501 
<a name="l00503"></a>00503     <a class="code" href="classfreeling_1_1tree.html#a5fa3f5c4eb930c9bf9f05b7cba8941ee">dep_tree::const_iterator</a> get_node_by_pos(<span class="keywordtype">size_t</span>) <span class="keyword">const</span>;
<a name="l00505"></a>00505     <a class="code" href="classfreeling_1_1tree.html#a5ba0306fd7e58c12de8a6d148d7dadbb">dep_tree::iterator</a> get_node_by_pos(<span class="keywordtype">size_t</span>);
<a name="l00507"></a>00507     <span class="keywordtype">void</span> rebuild_node_index();
<a name="l00508"></a>00508   };
<a name="l00509"></a>00509 
<a name="l00510"></a>00510 
<a name="l00511"></a>00511 
<a name="l00517"></a>00517 
<a name="l00518"></a><a class="code" href="classfreeling_1_1processor__status.html">00518</a>   <span class="keyword">class </span><a class="code" href="classfreeling_1_1processor__status.html" title="Virtual class to store the processing state of a sentence.">processor_status</a> {
<a name="l00519"></a>00519   <span class="keyword">public</span>:
<a name="l00520"></a>00520     <a class="code" href="classfreeling_1_1processor__status.html#a0dd7c67b7c6688730f80fd2d1d9d9ad7" title="Virtual class to store the processing state of a sentence.">processor_status</a>();
<a name="l00521"></a><a class="code" href="classfreeling_1_1processor__status.html#af0b72d7408082f2720c15abf8eb7db55">00521</a>     <span class="keyword">virtual</span> <a class="code" href="classfreeling_1_1processor__status.html#af0b72d7408082f2720c15abf8eb7db55">~processor_status</a>() {};
<a name="l00522"></a>00522   };
<a name="l00523"></a>00523 
<a name="l00524"></a>00524 
<a name="l00530"></a>00530 
<a name="l00531"></a><a class="code" href="classfreeling_1_1sentence.html">00531</a>   <span class="keyword">class </span>WINDLL <a class="code" href="classfreeling_1_1sentence.html" title="Class sentence is just a list of words that someone (the splitter) has validated it as a complete sen...">sentence</a> : <span class="keyword">public</span> std::<a class="code" href="classstd_1_1list.html">list</a>&lt;word&gt; {
<a name="l00532"></a>00532   <span class="keyword">private</span>:
<a name="l00533"></a>00533     <span class="comment">// sentence identifier, in case user application wants to set it.</span>
<a name="l00534"></a><a class="code" href="classfreeling_1_1sentence.html#aa6e01b320089b4e87ff5a22a4fd19da4">00534</a>     std::wstring <a class="code" href="classfreeling_1_1sentence.html#aa6e01b320089b4e87ff5a22a4fd19da4">sent_id</a>;
<a name="l00535"></a>00535     <span class="comment">// vector with pointers to sentence words, for fast access by position</span>
<a name="l00536"></a><a class="code" href="classfreeling_1_1sentence.html#a2d0a148fb306d9dcc27c987677519600">00536</a>     std::vector&lt;word*&gt; <a class="code" href="classfreeling_1_1sentence.html#a2d0a148fb306d9dcc27c987677519600">wpos</a>; 
<a name="l00537"></a>00537     <span class="comment">// parse tree (if sentence parsed)</span>
<a name="l00538"></a><a class="code" href="classfreeling_1_1sentence.html#ad2c4e3306e8c908cd2bcfa8f176cde72">00538</a>     std::map&lt;int,parse_tree&gt; <a class="code" href="classfreeling_1_1sentence.html#ad2c4e3306e8c908cd2bcfa8f176cde72">pts</a>;
<a name="l00539"></a>00539     <span class="comment">// dependencey tree (if sentence dep. parsed)</span>
<a name="l00540"></a><a class="code" href="classfreeling_1_1sentence.html#aa55f73b6494bfb1cb65563e452e55209">00540</a>     std::map&lt;int,dep_tree&gt; <a class="code" href="classfreeling_1_1sentence.html#aa55f73b6494bfb1cb65563e452e55209">dts</a>;
<a name="l00541"></a>00541     <span class="comment">// clone sentence (used by assignment/copy constructors)</span>
<a name="l00542"></a>00542     <span class="keywordtype">void</span> clone(<span class="keyword">const</span> <a class="code" href="classfreeling_1_1sentence.html" title="Class sentence is just a list of words that someone (the splitter) has validated it as a complete sen...">sentence</a> &amp;);
<a name="l00543"></a>00543     <span class="comment">// stack processing status for processor currently analyzing the sentence</span>
<a name="l00544"></a>00544     <span class="comment">// (there might be a hierarchy of embeeded processors, thus the stack)</span>
<a name="l00545"></a><a class="code" href="classfreeling_1_1sentence.html#a3f5711e13ddded2e767d8fa0d140fc23">00545</a>     std::list&lt;processor_status*&gt; <a class="code" href="classfreeling_1_1sentence.html#a3f5711e13ddded2e767d8fa0d140fc23">status</a>;
<a name="l00546"></a>00546 
<a name="l00547"></a>00547   <span class="keyword">public</span>:
<a name="l00548"></a><a class="code" href="classfreeling_1_1sentence.html#a16097e3f3bf27db667232d7bcdc0c0ca">00548</a>     <span class="keyword">typedef</span> std::pair&lt;std::wstring, std::map&lt;int,std::wstring&gt; &gt; <a class="code" href="classfreeling_1_1sentence.html#a16097e3f3bf27db667232d7bcdc0c0ca">pred_arg_set</a>;
<a name="l00549"></a><a class="code" href="classfreeling_1_1sentence.html#a24483796baf87d3bad38efd23e1aa303">00549</a>     std::map&lt;int,pred_arg_set&gt; <a class="code" href="classfreeling_1_1sentence.html#a24483796baf87d3bad38efd23e1aa303">pred_args</a>;
<a name="l00550"></a>00550 
<a name="l00551"></a>00551     <a class="code" href="classfreeling_1_1sentence.html" title="Class sentence is just a list of words that someone (the splitter) has validated it as a complete sen...">sentence</a>();
<a name="l00552"></a>00552     <a class="code" href="classfreeling_1_1sentence.html" title="Class sentence is just a list of words that someone (the splitter) has validated it as a complete sen...">sentence</a>(<span class="keyword">const</span> std::list&lt;word&gt;&amp;);
<a name="l00554"></a>00554     <a class="code" href="classfreeling_1_1sentence.html" title="Class sentence is just a list of words that someone (the splitter) has validated it as a complete sen...">sentence</a>(<span class="keyword">const</span> <a class="code" href="classfreeling_1_1sentence.html" title="Class sentence is just a list of words that someone (the splitter) has validated it as a complete sen...">sentence</a> &amp;);
<a name="l00556"></a>00556     <a class="code" href="classfreeling_1_1sentence.html" title="Class sentence is just a list of words that someone (the splitter) has validated it as a complete sen...">sentence</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classfreeling_1_1sentence.html" title="Class sentence is just a list of words that someone (the splitter) has validated it as a complete sen...">sentence</a>&amp;);
<a name="l00558"></a>00558     <span class="keyword">const</span> <a class="code" href="classfreeling_1_1word.html" title="Class word stores all info related to a word: form, list of analysis, list of tokens (if multiword)...">word</a>&amp; operator[](<span class="keywordtype">size_t</span>) <span class="keyword">const</span>;
<a name="l00559"></a>00559     <a class="code" href="classfreeling_1_1word.html" title="Class word stores all info related to a word: form, list of analysis, list of tokens (if multiword)...">word</a>&amp; operator[](<span class="keywordtype">size_t</span>);
<a name="l00561"></a>00561     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_kbest() <span class="keyword">const</span>;
<a name="l00563"></a>00563     <span class="keywordtype">void</span> push_back(<span class="keyword">const</span> <a class="code" href="classfreeling_1_1word.html" title="Class word stores all info related to a word: form, list of analysis, list of tokens (if multiword)...">word</a> &amp;);
<a name="l00565"></a>00565     <span class="keywordtype">void</span> rebuild_word_index();
<a name="l00566"></a>00566  
<a name="l00567"></a>00567     <span class="keywordtype">void</span> clear();
<a name="l00568"></a>00568 
<a name="l00569"></a>00569     <span class="keywordtype">void</span> set_sentence_id(<span class="keyword">const</span> std::wstring &amp;);
<a name="l00570"></a>00570     std::wstring get_sentence_id();
<a name="l00571"></a>00571 
<a name="l00572"></a>00572     <span class="keywordtype">void</span> set_parse_tree(<span class="keyword">const</span> <a class="code" href="classfreeling_1_1parse__tree.html" title="Class parse tree is used to store the results of parsing.">parse_tree</a> &amp;, <span class="keywordtype">int</span> k=0);
<a name="l00573"></a>00573     <a class="code" href="classfreeling_1_1parse__tree.html" title="Class parse tree is used to store the results of parsing.">parse_tree</a> &amp; get_parse_tree(<span class="keywordtype">int</span> k=0);
<a name="l00574"></a>00574     <span class="keyword">const</span> <a class="code" href="classfreeling_1_1parse__tree.html" title="Class parse tree is used to store the results of parsing.">parse_tree</a> &amp; get_parse_tree(<span class="keywordtype">int</span> k=0) <span class="keyword">const</span>;
<a name="l00575"></a>00575     <span class="keywordtype">bool</span> is_parsed() <span class="keyword">const</span>;
<a name="l00576"></a>00576 
<a name="l00577"></a>00577     <span class="keywordtype">void</span> set_dep_tree(<span class="keyword">const</span> <a class="code" href="classfreeling_1_1dep__tree.html" title="class dep_tree stores a dependency tree">dep_tree</a> &amp;, <span class="keywordtype">int</span> k=0);
<a name="l00578"></a>00578     <a class="code" href="classfreeling_1_1dep__tree.html" title="class dep_tree stores a dependency tree">dep_tree</a> &amp; get_dep_tree(<span class="keywordtype">int</span> k=0);
<a name="l00579"></a>00579     <span class="keyword">const</span> <a class="code" href="classfreeling_1_1dep__tree.html" title="class dep_tree stores a dependency tree">dep_tree</a> &amp; get_dep_tree(<span class="keywordtype">int</span> k=0) <span class="keyword">const</span>;
<a name="l00580"></a>00580     <span class="keywordtype">bool</span> is_dep_parsed() <span class="keyword">const</span>;
<a name="l00581"></a>00581 
<a name="l00583"></a>00583     <a class="code" href="classfreeling_1_1processor__status.html" title="Virtual class to store the processing state of a sentence.">processor_status</a>* get_processing_status();
<a name="l00584"></a>00584     <span class="keyword">const</span> <a class="code" href="classfreeling_1_1processor__status.html" title="Virtual class to store the processing state of a sentence.">processor_status</a>* get_processing_status() <span class="keyword">const</span>;
<a name="l00586"></a>00586     <span class="keywordtype">void</span> set_processing_status(<a class="code" href="classfreeling_1_1processor__status.html" title="Virtual class to store the processing state of a sentence.">processor_status</a> *);
<a name="l00588"></a>00588     <span class="keywordtype">void</span> clear_processing_status();
<a name="l00589"></a>00589 
<a name="l00591"></a>00591     std::vector&lt;word&gt; get_words() <span class="keyword">const</span>;
<a name="l00593"></a>00593     sentence::iterator words_begin();
<a name="l00594"></a>00594     sentence::const_iterator words_begin() <span class="keyword">const</span>;
<a name="l00595"></a>00595     sentence::iterator words_end();
<a name="l00596"></a>00596     sentence::const_iterator words_end() <span class="keyword">const</span>;
<a name="l00597"></a>00597   };
<a name="l00598"></a>00598 
<a name="l00603"></a>00603 
<a name="l00604"></a><a class="code" href="classfreeling_1_1paragraph.html">00604</a>   <span class="keyword">class </span>WINDLL <a class="code" href="classfreeling_1_1paragraph.html" title="Class paragraph is just a list of sentences that someone has validated it as a paragraph.">paragraph</a> : <span class="keyword">public</span> std::<a class="code" href="classstd_1_1list.html">list</a>&lt;sentence&gt; {
<a name="l00605"></a>00605   <span class="keyword">public</span>:
<a name="l00606"></a><a class="code" href="classfreeling_1_1paragraph.html#a809ef171a6d36da51ba211c9c5e9a1a0">00606</a>     <a class="code" href="classfreeling_1_1paragraph.html#a809ef171a6d36da51ba211c9c5e9a1a0">paragraph</a>() {}
<a name="l00607"></a><a class="code" href="classfreeling_1_1paragraph.html#ab6ea63435acd5e1aced04fb4f8ba4228">00607</a>     <span class="keyword">virtual</span> <a class="code" href="classfreeling_1_1paragraph.html#ab6ea63435acd5e1aced04fb4f8ba4228">~paragraph</a>() {}
<a name="l00608"></a>00608   };
<a name="l00609"></a>00609 
<a name="l00614"></a>00614 
<a name="l00615"></a><a class="code" href="classfreeling_1_1document.html">00615</a>   <span class="keyword">class </span>WINDLL <a class="code" href="classfreeling_1_1document.html" title="Class document is a list of paragraphs.">document</a> : <span class="keyword">public</span> std::<a class="code" href="classstd_1_1list.html">list</a>&lt;paragraph&gt; {
<a name="l00616"></a>00616 
<a name="l00617"></a>00617   <span class="keyword">private</span>:
<a name="l00618"></a><a class="code" href="classfreeling_1_1document.html#a74b7ffbeb6364be6256fc06623c6216c">00618</a>     <a class="code" href="classfreeling_1_1paragraph.html" title="Class paragraph is just a list of sentences that someone has validated it as a paragraph.">paragraph</a> <a class="code" href="classfreeling_1_1document.html#a74b7ffbeb6364be6256fc06623c6216c">title</a>;
<a name="l00619"></a><a class="code" href="classfreeling_1_1document.html#ab2c6c40b23181252d529f8c5422d2222">00619</a>     std::multimap&lt;int,std::wstring&gt; <a class="code" href="classfreeling_1_1document.html#ab2c6c40b23181252d529f8c5422d2222">group2node</a>;
<a name="l00620"></a><a class="code" href="classfreeling_1_1document.html#a936d5283cef82a0cd7c75405cc054af2">00620</a>     std::map&lt;std::wstring,int&gt; <a class="code" href="classfreeling_1_1document.html#a936d5283cef82a0cd7c75405cc054af2">node2group</a>;
<a name="l00621"></a><a class="code" href="classfreeling_1_1document.html#a914e5229b8cab97e0e4c544dc397a893">00621</a>     <span class="keywordtype">int</span> <a class="code" href="classfreeling_1_1document.html#a914e5229b8cab97e0e4c544dc397a893">last_group</a>;
<a name="l00622"></a>00622 
<a name="l00623"></a>00623   <span class="keyword">public</span>:
<a name="l00624"></a>00624     <a class="code" href="classfreeling_1_1document.html" title="Class document is a list of paragraphs.">document</a>();
<a name="l00626"></a>00626     <span class="keywordtype">void</span> add_positive(<span class="keyword">const</span> std::wstring &amp;<a class="code" href="classfreeling_1_1node.html" title="Class node stores nodes of a parse_tree Each node in the tree is either a label (intermediate node) o...">node</a>, <span class="keywordtype">int</span> group);
<a name="l00628"></a>00628     <span class="keywordtype">void</span> add_positive(<span class="keyword">const</span> std::wstring &amp;node1, <span class="keyword">const</span> std::wstring &amp;node2);
<a name="l00630"></a>00630     <span class="keywordtype">int</span> get_coref_group(<span class="keyword">const</span> std::wstring&amp;) <span class="keyword">const</span>;
<a name="l00632"></a>00632     std::list&lt;std::wstring&gt; get_coref_nodes(<span class="keywordtype">int</span>) <span class="keyword">const</span>;
<a name="l00634"></a>00634     <span class="keywordtype">bool</span> is_coref(<span class="keyword">const</span> std::wstring &amp;, <span class="keyword">const</span> std::wstring &amp;) <span class="keyword">const</span>;
<a name="l00635"></a>00635   };
<a name="l00636"></a>00636 
<a name="l00637"></a>00637 } <span class="comment">// namespace</span>
<a name="l00638"></a>00638 
<a name="l00639"></a>00639 <span class="preprocessor">#endif</span>
<a name="l00640"></a>00640 <span class="preprocessor"></span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 9 2013 10:17:17 for FreeLing by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
